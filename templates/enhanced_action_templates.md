# Enhanced NeoCoder Action Templates
# Integrating MVP Agent, Coder Agent, and Adaptive Engineering Lead protocols

## MVP_DESIGN Template

**Keyword:** MVP_DESIGN
**Name:** MVP Design & Planning Workflow  
**Description:** Comprehensive MVP outline generation using structured exploration framework
**Protocol:** MVP Agent Integration

### Steps:

#### Phase 1: Core Principles (Why?)
- **Define the Principle of Inquiry**: What core problem does this MVP solve?
- **Establish primary value proposition**
- **Align with ethical considerations**: harm avoidance, wisdom, integrity, fairness, empathy
- **Document the "why" clearly before proceeding**

#### Phase 2: Dimensional Axes (What?)
- **Intent**: Specific purpose (expression, evocation, problem-solving)
- **Method**: High-level approaches, techniques, constraints
- **Output**: Tangible outcome (visual, textual, experiential)
- **Core Features**: Minimum viable feature set prioritized by user need and feasibility
- **Out-of-Scope**: Features explicitly excluded from MVP (document for future iterations)

#### Phase 3: Recursive Frameworks (How?)
- **Architectural Design**: High-level software architecture (scalability, performance)
- **Technology Stack**: Programming languages, frameworks, databases
- **Front-End**: UI elements, responsiveness, accessibility considerations
- **Back-End**: Server logic, database interactions, integrations
- **Full-Stack Integration**: Component integration and comprehensive testing approach
- **AI/ML Integration**: Model types, data requirements, evaluation metrics (if applicable)

#### Phase 4: Constraints as Catalysts (What if?)
- **Technical limitations**: budget, time, existing infrastructure
- **Functional limitations**: data availability, third-party API restrictions
- **Innovation stimulation**: How constraints drive creative solutions within MVP scope

#### Phase 5: Controlled Emergence (How Else?)
- **Controlled experimentation**: Areas for novelty/unexpected solutions
- **A/B testing opportunities**: Minor UI variations, algorithm parameter exploration
- **Surprise/novelty control**: Aligned with core purpose and user needs

#### Phase 6: Feedback Loops (What Next?)
- **Validation strategy**: unit, integration, user acceptance testing
- **Anti-hallucination mechanisms**: Prevent self-sealing patterns in output
- **Bias detection**: Address during development and validation
- **User feedback integration**: Collection and iterative refinement processes

#### Phase 7: Adaptive Flexibility (What Now?)
- **Future enhancement accommodation**: Design for scalability beyond initial scope
- **Meta-level adjustments**: Development process improvements
- **Version control strategies**: Code quality assurance for long-term maintainability

#### Phase 8: Deliverable Structure
- **Present MVP outline**: Clear headings, actionable bullet points
- **Flag uncertainties**: Suggest deeper validation where confidence is low
- **Prioritize clarity**: Feasibility-focused for MVP implementation

---

## META_CODE Template

**Keyword:** META_CODE
**Name:** Meta-Cognitive AI Coding Protocol
**Description:** Advanced coding workflow with meta-validation and fail-safe intelligence
**Protocol:** Coder Agent Integration

### Steps:

#### üõ† Init (Observe & Understand)
- **Observe**: Understand repo structure, design patterns, domain architecture
- **Defer**: Refrain from code generation until system understanding reaches threshold
- **Integrate**: Align with existing conventions and architectural philosophy
- **Meta-Validate**:
  - Consistency: Ensure internal alignment of design goals and constraints
  - Completeness: Confirm all relevant design factors are considered
  - Soundness: Ensure proposed changes logically follow from assumptions
  - Expressiveness: Allow edge-case accommodation within general structure

#### üöÄ Execute (Targeted Implementation)
- **Target**: Modify primary source directly (no workaround scripts)
- **Scope**: Enact minimum viable change to fix targeted issue
- **Leverage**: Prefer existing abstractions over introducing new ones
- **Preserve**: Assume complexity is intentional; protect advanced features
- **Hypothesize**: "If X is modified, then Y should change in Z way"
- **Test**: Create local validations specific to this hypothesis

#### üîé Validate (Verification & Review)
- **Test**: Define and run specific validation steps for each change
- **Verify**: Confirm no degradation of existing behaviors or dependencies
- **Review**:
  - Self-audit for consistency with codebase patterns
  - Check for unintended architectural side effects
- **Reflect & Refactor**:
  - Log rationale behind decisions
  - Adjust reasoning if change outcomes differ from expectations

#### üì° Communicate++ (Documentation)
- **What**: Issue + root cause, framed in architectural context
- **Where**: File + line-level references
- **How**: Precise code delta required
- **Why**: Rationale including discarded alternatives
- **Trace**: Show logical steps from diagnosis to decision
- **Context**: Identify impacted modules, dependencies, workflows

#### ‚ö†Ô∏è Fail-Safe Intelligence
- **Avoid**:
  - Workaround scripts or non-integrated changes
  - Oversimplification of complex components
  - Premature solutioning before contextual analysis
  - Inconsistent or redundant implementations
- **Flag Uncertainty**: Surface confidence level and assumptions
- **Risk-Aware**: Estimate impact level (low/medium/high), guard against coupling effects

---

## PROJECT_LEAD Template  

**Keyword:** PROJECT_LEAD
**Name:** Adaptive Engineering Lead Protocol
**Description:** Collaborative software development with understanding, execution, and iteration phases
**Protocol:** Adaptive Engineering Lead Integration

### Steps:

#### Phase 1: Understanding & Planning (The Blueprint)

**Comprehensive Analysis:**
- Thoroughly analyze all provided materials: project descriptions, development plans, existing code, documentation, repository structures, user stories, technical constraints
- Identify core objectives, key features, and success criteria for the project or task

**Strategic Plan Development:**
- If detailed step-by-step development plan is not provided, create one
- Break down project into logical, small, independently testable tasks
- For each task, define:
  - Specific file(s) to be created or modified
  - Clear acceptance criteria or expected outcomes
  - Identified dependencies on other tasks or modules
  - Potential challenges requiring special attention
- Prioritize modularity, maintainability, and efficiency

**Clarification & Confirmation:**
- Present understanding of objectives and proposed development plan
- Ask specific clarifying questions for ambiguities or contradictions
- Await confirmation or refinement requests before proceeding

#### Phase 2: Execution & Iteration (The Build Cycle)

**Focused Implementation:**
- Implement one primary task (or small, coherent group of sub-tasks) at a time
- **CODING PROTOCOL**:
  - Minimalism & Precision: Write only necessary, clean, efficient code
  - Isolation: No sweeping changes or unrelated edits
  - Quality: Precise, modular, well-commented, inherently testable code
  - Non-Regression: Do not break existing functionality
  - Transparency: State new dependencies, configuration steps clearly
  - Assumption Articulation: State minor assumptions clearly

**Progress Reporting & Handoff:**
- After completing each task, indicate:
  - What was accomplished
  - Which files were created or modified
  - Specific instructions for testing implemented functionality
- Provide summary and code/diffs as appropriate
- Await feedback before proceeding to next task

#### Phase 3: Adaptability & Problem Solving (The Agile Response)

**Proactive Obstacle Management:**
- If encountering significant obstacles or contradictions:
  - PAUSE implementation of specific part
  - Articulate problem nature and implications
  - Propose 2-3 viable alternative solutions with pros/cons
  - Seek guidance on how to proceed

**Responding to "Quirks" & Learning:**
- Explain reasoning for unusual but valid patterns when queried
- Treat moments as opportunities to refine understanding or uncover efficiencies

**Plan Evolution:**
- Adapt/revise overall development plan based on:
  - Implementation insights
  - New requirements
  - Resolved obstacles
- Discuss significant deviations from agreed plan with stakeholders

#### Interaction Style:
- **Methodical & Structured**: Think step-by-step, refer back to plan
- **Collaborative Partner**: Augment capabilities, proactive communication
- **Clarity & Conciseness**: Clear explanations, avoid unnecessary jargon
- **User-Centric**: Prioritize goals and constraints, responsive to feedback
- **Continuous Learning**: Understand preferences and project nuances deeply

---

## Integration Notes

These enhanced templates can be used alongside existing NeoCoder action templates (FIX, REFACTOR, DEPLOY, etc.) to provide more sophisticated workflows for complex projects.

**Usage Examples:**
- Use `MVP_DESIGN` for new project planning
- Use `META_CODE` for complex refactoring or critical bug fixes
- Use `PROJECT_LEAD` for collaborative development workflows
- Combine with existing templates for comprehensive coverage

**Integration with NeoCoder:**
- These templates follow the same structure as existing action templates
- Can be added to Neo4j using standard template creation methods
- Support the same workflow execution logging and tracking
- Compatible with existing project management and best practices systems
